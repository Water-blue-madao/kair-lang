# KAIR 仕様メモ

**警告: この仕様は毎日変わります。最新のコミットを確認してください。**

KAIR (Kernel Assembly IR) - 拡張子: `.kir`

## 概要

x64とARM64の差異を吸収する最小限のアセンブリラッパー。すべての状態はメモリで表現し、レジスタは完全に隠蔽。

## 実行モデル

- トップレベルから順次実行
- 制御フローは `goto` と `goto ... if` のみ
- プログラム終了は `goto END`

## コメント

```kir
// 単行コメント
/* 複数行コメント */
s[0] = 10  // 文末コメント
```

## メモリアクセス

### 統一構文: `[base + offset]`

3種類のベースレジスタ:
- `sp` - スタックポインタ（ネイティブRSP）
- `data` - データセクション（書き換え可能）
- `const` - 読み取り専用データセクション

```kir
[sp + 0] = 10        // スタック
[data + 8] = 20      // グローバルデータ
[const + 16] = 30    // 読み取り専用（初期化時のみ）
```

**重要**: 統一構文 `[base + offset]` のみがサポートされます。

## スタックポインタ（重要）

### ネイティブRSPとの対応

`sp` は**ネイティブのRSP（x64）/ SP（ARM64）を直接操作**します。

```kir
sp -= 40    // スタックを40バイト確保（実装済み）
sp += 16    // スタックを16バイト解放（実装済み）
```

### スタックの成長方向と操作

**x64/ARM64のアセンブリでは、スタックはメモリの「下方向」(高位アドレスから低位アドレス)に成長します**

```
高位アドレス ←─ スタックトップ（現在の sp）
    ↑
    │  sp -= 8  で確保される領域
    │
低位アドレス
```

- **スタック確保**: `sp -= 40` はスタックポインタを**減らし**、40バイト分の領域を確保
- **スタック解放**: `sp += 16` はスタックポインタを**増やし**、16バイト分を解放
- **アクセス**: `s[0]`, `s[8]`, `s[16]` ... は、配列と同じように、 sp からの正のオフセット（高位アドレス側）でアクセス

**KIR の記法はアセンブリと同じです:**
- x64: `sub rsp, 40` → KIR: `sp -= 40`
- x64: `add rsp, 16` → KIR: `sp += 16`

### 内部実装の制約

**コンパイラ実装者向け重要事項:**

- 内部実装で `push`/`pop` を使ってはいけない（RSPが変化してしまう）
- 二項演算などの一時保存には専用レジスタ（r8, r9など）を使用
- `[sp + offset]` は常に `[rsp + offset]` に変換される
- ユーザーコードが明示的に `sp +=` した場合のみRSPが変化すべき

### 将来の push/pop 対応

```kir
push s[0]    // RSP を操作して値をプッシュ（将来実装予定）
pop s[0]     // RSP を操作して値をポップ（将来実装予定）
```

これらは `sp` を直接変更するため、既存の `s[offset]` アクセスに影響する。

## データ初期化（トップレベル制約）

プログラムの**最初**にのみデータ初期化が可能:

```kir
// トップレベル: データ初期化のみ
[data + 0] = 10
[data + 8] = 20
[const + 0] = 100

// ここからコード（最初の非データ初期化文以降）
s[0] = d[0]
s[8] = d[8]
```

**制約:**
- `[data + ...]` または `[const + ...]` への静的代入のみ
- 最初の非データ初期化文（`s[...]` など）が現れたらコードセクション開始
- 以降はデータ初期化不可

## ベースアドレス値（重要）

データセクションおよび定数セクションの**ベースアドレス**を値として取得できます。

```kir
s[8] = data         // データセクションのベースアドレスを取得
s[16] = const       // 定数セクションのベースアドレスを取得
s[8] += 32          // アドレスにオフセットを加算
```

**重要な区別:**
- `d[0]` = データセクションのオフセット0の**値**をロード
- `data` = データセクションの**ベースアドレス**をロード（値ではない）

**用途:**
- システムコールにバッファアドレスを渡す
- ポインタ演算

**例:**
```kir
[data + 0] = 0x48656C6C6F  // "Hello"

s[8] = data              // データセクションのアドレスを取得
syscall WriteFile, handle, s[8], 5, written_ptr, 0  // アドレスを渡す
```

## スタックアライメント

スタックを指定したバイト境界に整列します（Windows x64では`call`前にRSP % 16 == 0が必須）。

```kir
align 16    // スタックを16バイト境界に整列
align 8     // スタックを8バイト境界に整列
```

**用途:**
- システムコール前の必須処理（Windows x64）
- パフォーマンス最適化

**注意:**
- 整列後はスタックオフセットが変化する可能性がある
- システムコールごとに `align 16` を実行することを推奨

## 演算

### 基本演算

```kir
s[0] = s[8] + s[16]       // 加算
s[0] = s[8] - s[16]       // 減算
s[0] = s[8] * s[16]       // 乗算
s[0] = s[8] /s s[16]      // 符号付き除算
s[0] = s[8] /u s[16]      // 符号なし除算
s[0] = s[8] %s s[16]      // 符号付き剰余
s[0] = s[8] %u s[16]      // 符号なし剰余
```

### ビット演算

```kir
s[0] = s[8] & s[16]       // AND
s[0] = s[8] | s[16]       // OR
s[0] = s[8] ^ s[16]       // XOR
s[0] = ~s[8]              // NOT
s[0] = s[8] << s[16]      // 左シフト
s[0] = s[8] >>s s[16]     // 算術右シフト
s[0] = s[8] >>u s[16]     // 論理右シフト
```

### 複合代入

```kir
s[0] += s[8]              // s[0] = s[0] + s[8]
s[0] -= s[8]
s[0] *= s[8]
s[0] /s= s[8]
s[0] &= s[8]
// など
```

### 単項演算

```kir
s[0] = -s[8]              // 符号反転
s[0] = ~s[8]              // ビット反転
```

## 条件付き代入と三項演算子

### 条件付き代入（実装済み）

条件が真の場合のみ代入を行います。

```kir
s[0] = 10 if s[8] >s 0           // s[8] > 0 なら s[0] = 10
d[8] = 100 if s[16] == 0         // s[16] == 0 なら d[8] = 100
```

### 三項演算子（実装済み）

条件に応じて異なる値を代入します。

```kir
s[0] = (s[8] >s 0) ? 100 : 200   // s[8] > 0 なら 100、そうでなければ 200
s[16] = (s[0] == 42) ? d[0] : d[8]
```

**構文:**
```kir
destination = (condition) ? true_value : false_value
```

**構文の制約:**
- **各文は1つの操作のみを表現** - KIRの構文はアセンブリ命令にほぼ1対1で対応しています
- 式を組み合わせたり、演算結果を直接別の場所で使うことはできません
- 不可能な例:
  ```kir
  s[0] = (s[8] + 10) * 2           // NG: 演算を組み合わせられない
  syscall ExitProcess, s[0] + 1    // NG: 引数で演算できない
  syscall WriteFile, h, data + 8, len, ptr, 0  // NG: data + 8 は不可
  s[0] = ((s[8] > 0) ? 10 : 20) + 5  // NG: 三項演算の結果を直接使えない
  ```
- 正しい書き方（中間結果を明示的に保存）:
  ```kir
  s[0] = s[8] + 10
  s[0] *= 2

  s[0] += 1
  syscall ExitProcess, s[0]

  s[16] = data
  s[16] += 8
  syscall WriteFile, h, s[16], len, ptr, 0

  s[0] = (s[8] > 0) ? 10 : 20
  s[0] += 5
  ```

## 制御フロー

### ラベル

```kir
s[0] = 10

# loop
s[0] -= 1
goto loop if s[0] >s 0
```

**重要:** ラベルの直前には空行が必要。

### 条件分岐

```kir
goto label if s[0] == s[8]
goto label if s[0] != s[8]
goto label if s[0] <s s[8]    // 符号付き
goto label if s[0] <u s[8]    // 符号なし
goto label if s[0] <=s s[8]
goto label if s[0] >s s[8]
goto label if s[0] >=s s[8]
```

### プログラム終了

```kir
goto END
```

終了コードは `s[0]` に格納。

## システムコール

Windows x64 システムコール（現在は Windows のみ対応）:

```kir
syscall ExitProcess, 42
syscall GetStdHandle, -11
syscall WriteFile, handle, address, length, written_ptr, 0
```

### 主なシステムコール

**ExitProcess**
```kir
syscall ExitProcess, exit_code
```

**GetStdHandle**
```kir
s[0] = syscall GetStdHandle, std_handle_type
// std_handle_type: -10 (stdin), -11 (stdout), -12 (stderr)
```

**WriteFile**
```kir
syscall WriteFile, handle, buffer_addr, length, bytes_written_ptr, 0
```

### システムコールの制約

- Windows x64 呼び出し規約に準拠
- 引数は最大6個（RCX, RDX, R8, R9, スタック×2）
- 戻り値は RAX（取得する場合は代入先を指定）
- スタックアライメント（16バイト境界）は**ユーザーが明示的に行う必要がある**（`align 16`）

**重要: アドレスの渡し方**
- バッファアドレスを渡す場合は `data` または `const` を使用
- `[data + 0]` は**値**、`data` は**アドレス**

### 例: Hello World

```kir
// データ初期化
[data + 0] = 0x57202C6F6C6C6548  // "Hello, W"
[data + 8] = 0x0A0D21646C726F    // "orld!\r\n"

// 標準出力ハンドル取得
align 16
s[0] = syscall GetStdHandle, -11

// バッファアドレスと書き込み先アドレスを準備
s[8] = data              // バッファのアドレス
s[16] = data
s[16] += 32              // 書き込みバイト数を格納するアドレス

// 書き込み
align 16
syscall WriteFile, s[0], s[8], 15, s[16], 0

// 終了
align 16
syscall ExitProcess, 0
```

## その他

### nop命令

```kir
pass           // nop 1回
pass * 5       // nop 5回（デバッグ用）
```

## サンプル

### ループと条件分岐

```kir
[data + 0] = 10

s[0] = d[0]

# loop
s[0] -= 1
goto loop if s[0] >s 0

syscall ExitProcess, s[0]

goto END
```

### 全記法の総合例

```kir
// データ初期化
[data + 0] = 10
[data + 8] = 20
[const + 0] = 3

// 基本アクセス（統一構文）
[sp + 0] = [data + 0]
[sp + 8] = [data + 8]

// シンタックスシュガー
s[16] = d[0]
s[24] = c[0]

// 演算（混在可能）
s[32] = [sp + 0] + d[8]
[sp + 40] = s[16] * c[0]

// 終了
syscall ExitProcess, s[40]

goto END
```

## BNF（簡略版）

```
program     ::= data_init* statement*
data_init   ::= "[" base "+" offset "]" "=" value
statement   ::= label | assignment | goto | syscall
assignment  ::= mem "=" expr | mem op= expr
goto        ::= "goto" id | "goto" id "if" cond
syscall     ::= "syscall" name ("," arg)*
mem         ::= sugar | unified
sugar       ::= "s" "[" expr "]" | "d" "[" expr "]" | "c" "[" expr "]"
unified     ::= "[" base "+" offset "]"
base        ::= "sp" | "data" | "const"
```
