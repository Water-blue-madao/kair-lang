# KAIR 仕様メモ

**警告: この仕様は毎日変わります。最新のコミットを確認してください。**

KAIR (Kernel Assembly IR) - 拡張子: `.kir`

## 概要

x64とARM64の差異を吸収する最小限のアセンブリラッパー。すべての状態はメモリで表現し、レジスタは完全に隠蔽。

## 実行モデル

- トップレベルから順次実行
- 制御フローは `goto` と `goto ... if` のみ
- プログラム終了は `goto END`

## コメント

```kir
// 単行コメント
/* 複数行コメント */
s[0] = 10  // 文末コメント
```

## メモリアクセス

### 統一構文: `[base + offset]`

3種類のベースレジスタ:
- `sp` - スタックポインタ（ネイティブRSP）
- `data` - データセクション（書き換え可能）
- `const` - 読み取り専用データセクション

```kir
[sp + 0] = 10        // スタック
[data + 8] = 20      // グローバルデータ
[const + 16] = 30    // 読み取り専用（初期化時のみ）
```

### シンタックスシュガー

簡潔な記述のための糖衣構文（内部的には `[base + offset]` に展開）:

```kir
s[0] = 10            // [sp + 0] = 10
d[8] = 20            // [data + 8] = 20
c[16]                // [const + 16]（読み取りのみ）
```

### メモリサイズ指定（将来実装予定）

```kir
s8[0]    // 1バイト（ゼロ拡張）
s16[0]   // 2バイト（ゼロ拡張）
s32[0]   // 4バイト（ゼロ拡張）
s64[0]   // 8バイト（デフォルト）

s8s[0]   // 1バイト（符号拡張）
s16s[0]  // 2バイト（符号拡張）
s32s[0]  // 4バイト（符号拡張）
```

d[], c[] も同様。

## スタックポインタ（重要）

### ネイティブRSPとの対応

`sp` は**ネイティブのRSP（x64）/ RSP（ARM64）を直接操作**します。

```kir
sp += 16    // RSP を操作（将来の push 実装時に対応）
sp -= 16    // RSP を操作（将来の pop 実装時に対応）
```

### スタックの成長方向

**KIRIでは、スタックは配列のように正方向に成長します。**

- x64: 実際のRSPは下向き（減少）に成長するが、KIRIでは正のオフセットでアクセス
- `s[0]`, `s[8]`, `s[16]` ... という順で高位アドレスに向かって並ぶ
- `sp += N` は「N バイト確保」の意味

### 内部実装の制約

**コンパイラ実装者向け重要事項:**

- 内部実装で `push`/`pop` を使ってはいけない（RSPが変化してしまう）
- 二項演算などの一時保存には専用レジスタ（r8, r9など）を使用
- `[sp + offset]` は常に `[rsp + offset]` に変換される
- ユーザーコードが明示的に `sp +=` した場合のみRSPが変化すべき

### 将来の push/pop 対応

```kir
push s[0]    // RSP を操作して値をプッシュ（将来実装予定）
pop s[0]     // RSP を操作して値をポップ（将来実装予定）
```

これらは `sp` を直接変更するため、既存の `s[offset]` アクセスに影響する。

## データ初期化（トップレベル制約）

プログラムの**最初**にのみデータ初期化が可能:

```kir
// トップレベル: データ初期化のみ
[data + 0] = 10
[data + 8] = 20
[const + 0] = 100

// ここからコード（最初の非データ初期化文以降）
s[0] = d[0]
s[8] = d[8]
```

**制約:**
- `[data + ...]` または `[const + ...]` への静的代入のみ
- 最初の非データ初期化文（`s[...]` など）が現れたらコードセクション開始
- 以降はデータ初期化不可

## 演算

### 基本演算

```kir
s[0] = s[8] + s[16]       // 加算
s[0] = s[8] - s[16]       // 減算
s[0] = s[8] * s[16]       // 乗算
s[0] = s[8] /s s[16]      // 符号付き除算
s[0] = s[8] /u s[16]      // 符号なし除算
s[0] = s[8] %s s[16]      // 符号付き剰余
s[0] = s[8] %u s[16]      // 符号なし剰余
```

### ビット演算

```kir
s[0] = s[8] & s[16]       // AND
s[0] = s[8] | s[16]       // OR
s[0] = s[8] ^ s[16]       // XOR
s[0] = ~s[8]              // NOT
s[0] = s[8] << s[16]      // 左シフト
s[0] = s[8] >>s s[16]     // 算術右シフト
s[0] = s[8] >>u s[16]     // 論理右シフト
```

### 複合代入

```kir
s[0] += s[8]              // s[0] = s[0] + s[8]
s[0] -= s[8]
s[0] *= s[8]
s[0] /s= s[8]
s[0] &= s[8]
// など
```

### 単項演算

```kir
s[0] = -s[8]              // 符号反転
s[0] = ~s[8]              // ビット反転
```

## 制御フロー

### ラベル

```kir
s[0] = 10

# loop
s[0] -= 1
goto loop if s[0] >s 0
```

**重要:** ラベルの直前には空行が必要。

### 条件分岐

```kir
goto label if s[0] == s[8]
goto label if s[0] != s[8]
goto label if s[0] <s s[8]    // 符号付き
goto label if s[0] <u s[8]    // 符号なし
goto label if s[0] <=s s[8]
goto label if s[0] >s s[8]
goto label if s[0] >=s s[8]
```

### プログラム終了

```kir
goto END
```

終了コードは `s[0]` に格納。

## システムコール

Windows x64 システムコール（現在は Windows のみ対応）:

```kir
syscall ExitProcess, 42
syscall GetStdHandle, -11
syscall WriteFile, handle, address, length, written_ptr, 0
```

### 主なシステムコール

**ExitProcess**
```kir
syscall ExitProcess, exit_code
```

**GetStdHandle**
```kir
s[0] = syscall GetStdHandle, std_handle_type
// std_handle_type: -10 (stdin), -11 (stdout), -12 (stderr)
```

**WriteFile**
```kir
syscall WriteFile, handle, buffer_addr, length, bytes_written_ptr, 0
```

### システムコールの制約

- Windows x64 呼び出し規約に準拠
- 引数は最大6個（RCX, RDX, R8, R9, スタック×2）
- 戻り値は RAX（取得する場合は代入先を指定）
- スタックアライメント（16バイト境界）は自動調整

### 例: Hello World

```kir
// データ初期化
[data + 0] = 0x6C6C6548    // "Hell"
[data + 8] = 0x57202C6F    // "o, W"
[data + 16] = 0x646C726F   // "orld"
[data + 24] = 0x0A21       // "!\n"

// 標準出力ハンドル取得
s[0] = syscall GetStdHandle, -11

// 書き込み
syscall WriteFile, s[0], [data + 0], 14, [data + 32], 0

// 終了
syscall ExitProcess, 0

goto END
```

## その他

### nop命令

```kir
pass           // nop
```

## サンプル

### ループと条件分岐

```kir
[data + 0] = 10

s[0] = d[0]

# loop
s[0] -= 1
goto loop if s[0] >s 0

syscall ExitProcess, s[0]

goto END
```

### 全記法の総合例

```kir
// データ初期化
[data + 0] = 10
[data + 8] = 20
[const + 0] = 3

// 基本アクセス（統一構文）
[sp + 0] = [data + 0]
[sp + 8] = [data + 8]

// シンタックスシュガー
s[16] = d[0]
s[24] = c[0]

// 演算（混在可能）
s[32] = [sp + 0] + d[8]
[sp + 40] = s[16] * c[0]

// 終了
syscall ExitProcess, s[40]

goto END
```

## BNF（簡略版）

```
program     ::= data_init* statement*
data_init   ::= "[" base "+" offset "]" "=" value
statement   ::= label | assignment | goto | syscall
assignment  ::= mem "=" expr | mem op= expr
goto        ::= "goto" id | "goto" id "if" cond
syscall     ::= "syscall" name ("," arg)*
mem         ::= sugar | unified
sugar       ::= "s" "[" expr "]" | "d" "[" expr "]" | "c" "[" expr "]"
unified     ::= "[" base "+" offset "]"
base        ::= "sp" | "data" | "const"
```
