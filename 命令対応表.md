# KAIR 命令対応表（完全ナイーブ実装）

この表は、KAIR命令がx64とARM64でどのように実装されるかを示します。
**完全ナイーブ実装**のため、最適化は一切行いません。

## 表記規則

- `rax`, `rbx` など: x64 レジスタ
- `x0`, `x1` など: ARM64 レジスタ
- `[...]`: メモリアクセス
- `// ...`: コメント

## 一時レジスタの方針

ナイーブ実装では**非揮発性(callee-save)レジスタを優先的に使用**します:

- **x64**: RBX, R12-R15を一時レジスタとして使用
  - RBPはベースポインタ用に予約する場合は除外
  - 現段階では外部から呼ばれる関数を生成しないため、保存/復元は不要
  - 将来的に関数エクスポート機能を追加する際は、プロローグ/エピローグで保存/復元が必要

- **ARM64**: X19-X28を一時レジスタとして使用
  - 現段階では外部から呼ばれる関数を生成しないため、保存/復元は不要
  - 将来的に関数エクスポート機能を追加する際は、プロローグ/エピローグで保存/復元が必要

---

## メモリアクセス

### 基本アクセス: `s[0] = 10`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, 10`<br>`mov [rsp + 0], rax` | 即値をレジスタ経由でストア |
| **ARM64** | `mov x0, #10`<br>`str x0, [sp, #0]` | 即値をレジスタ経由でストア |

### ロード: `s[0] = s[8]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 8]`<br>`mov [rsp + 0], rax` | メモリ→レジスタ→メモリ |
| **ARM64** | `ldr x0, [sp, #8]`<br>`str x0, [sp, #0]` | メモリ→レジスタ→メモリ |

### データセクションアクセス: `s[0] = d[8]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64 (LLVM MC)** | `mov rax, [rip + _data_base + 8]`<br>`mov [rsp + 0], rax` | RIP相対で直接メモリアクセス |
| **ARM64** | `adrp x10, _data_base`<br>`add x10, x10, :lo12:_data_base`<br>`ldr x0, [x10, #8]`<br>`str x0, [sp, #0]` | ページアドレス + lo12 + オフセット |

### 読み取り専用アクセス: `s[0] = c[8]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64 (LLVM MC)** | `mov rax, [rip + _rodata_base + 8]`<br>`mov [rsp + 0], rax` | RIP相対で直接メモリアクセス |
| **ARM64** | `adrp x10, _rodata_base`<br>`add x10, x10, :lo12:_rodata_base`<br>`ldr x0, [x10, #8]`<br>`str x0, [sp, #0]` | ページアドレス + lo12 + オフセット |

---

## 算術演算

### 加算: `s[0] = s[8] + s[16]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 8]`<br>`add rax, [rsp + 16]`<br>`mov [rsp + 0], rax` | メモリ→レジスタ→演算→ストア |
| **ARM64** | `ldr x0, [sp, #8]`<br>`ldr x1, [sp, #16]`<br>`add x0, x0, x1`<br>`str x0, [sp, #0]` | 3オペランド演算が自然 |

### 減算: `s[0] = s[8] - s[16]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 8]`<br>`sub rax, [rsp + 16]`<br>`mov [rsp + 0], rax` | メモリ→レジスタ→演算→ストア |
| **ARM64** | `ldr x0, [sp, #8]`<br>`ldr x1, [sp, #16]`<br>`sub x0, x0, x1`<br>`str x0, [sp, #0]` | 3オペランド演算 |

### 乗算: `s[0] = s[8] * s[16]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 8]`<br>`imul rax, [rsp + 16]`<br>`mov [rsp + 0], rax` | imulは下位64bitのみ保持 |
| **ARM64** | `ldr x0, [sp, #8]`<br>`ldr x1, [sp, #16]`<br>`mul x0, x0, x1`<br>`str x0, [sp, #0]` | mulは下位64bitしか保持しないため符号に依存しない |

### 符号付き除算: `s[0] = s[8] /s s[16]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 8]`<br>`mov r8, rax`<br>`mov rbx, [rsp + 16]`<br>`mov rax, r8`<br>`cqo`<br>`idiv rbx`<br>`mov [rsp + 0], rax` | RAX:RDX ÷ RBX → RAX |
| **ARM64** | `ldr x0, [sp, #8]`<br>`ldr x1, [sp, #16]`<br>`sdiv x0, x0, x1`<br>`str x0, [sp, #0]` | 符号付き除算命令 |

### 符号なし除算: `s[0] = s[8] /u s[16]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 8]`<br>`mov r8, rax`<br>`mov rbx, [rsp + 16]`<br>`mov rax, r8`<br>`xor rdx, rdx`<br>`div rbx`<br>`mov [rsp + 0], rax` | RDXクリア必須 |
| **ARM64** | `ldr x0, [sp, #8]`<br>`ldr x1, [sp, #16]`<br>`udiv x0, x0, x1`<br>`str x0, [sp, #0]` | 符号なし除算命令 |

### 剰余（符号付き）: `s[0] = s[8] %s s[16]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 8]`<br>`mov r8, rax`<br>`mov rbx, [rsp + 16]`<br>`mov rax, r8`<br>`cqo`<br>`idiv rbx`<br>`mov [rsp + 0], rdx` | 商はRAX、余りはRDX |
| **ARM64** | `ldr x0, [sp, #8]`<br>`ldr x1, [sp, #16]`<br>`sdiv x2, x0, x1`<br>`msub x0, x2, x1, x0`<br>`str x0, [sp, #0]` | x0 - (x0/x1)*x1 で計算 |

### 剰余(符号なし): `s[0] = s[8] %u s[16]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 8]`<br>`xor rdx, rdx`<br>`mov rbx, [rsp + 16]`<br>`div rbx`<br>`mov [rsp + 0], rdx` | 商はRAX、余りはRDX |
| **ARM64** | `ldr x0, [sp, #8]`<br>`ldr x1, [sp, #16]`<br>`udiv x2, x0, x1`<br>`msub x0, x2, x1, x0`<br>`str x0, [sp, #0]` | x0 - (x0/x1)*x1 で計算 |

---

## ビット演算

### AND: `s[0] = s[8] & s[16]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 8]`<br>`and rax, [rsp + 16]`<br>`mov [rsp + 0], rax` | ビット単位AND |
| **ARM64** | `ldr x0, [sp, #8]`<br>`ldr x1, [sp, #16]`<br>`and x0, x0, x1`<br>`str x0, [sp, #0]` | ビット単位AND |

### OR: `s[0] = s[8] | s[16]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 8]`<br>`or rax, [rsp + 16]`<br>`mov [rsp + 0], rax` | ビット単位OR |
| **ARM64** | `ldr x0, [sp, #8]`<br>`ldr x1, [sp, #16]`<br>`orr x0, x0, x1`<br>`str x0, [sp, #0]` | ビット単位OR |

### XOR: `s[0] = s[8] ^ s[16]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 8]`<br>`xor rax, [rsp + 16]`<br>`mov [rsp + 0], rax` | ビット単位XOR |
| **ARM64** | `ldr x0, [sp, #8]`<br>`ldr x1, [sp, #16]`<br>`eor x0, x0, x1`<br>`str x0, [sp, #0]` | ビット単位XOR |

### NOT: `s[0] = ~s[8]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 8]`<br>`not rax`<br>`mov [rsp + 0], rax` | ビット反転 |
| **ARM64** | `ldr x0, [sp, #8]`<br>`mvn x0, x0`<br>`str x0, [sp, #0]` | ビット反転 |

### 左シフト: `s[0] = s[8] << s[16]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 8]`<br>`mov r8, rax`<br>`mov rcx, [rsp + 16]`<br>`mov rax, r8`<br>`shl rax, cl`<br>`mov [rsp + 0], rax` | シフト量はCL（RCXの下位8bit） |
| **ARM64** | `ldr x0, [sp, #8]`<br>`ldr x1, [sp, #16]`<br>`lslv x0, x0, x1`<br>`str x0, [sp, #0]` | 可変量左シフト |

### 算術右シフト: `s[0] = s[8] >>s s[16]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 8]`<br>`mov r8, rax`<br>`mov rcx, [rsp + 16]`<br>`mov rax, r8`<br>`sar rax, cl`<br>`mov [rsp + 0], rax` | 符号ビット拡張 |
| **ARM64** | `ldr x0, [sp, #8]`<br>`ldr x1, [sp, #16]`<br>`asrv x0, x0, x1`<br>`str x0, [sp, #0]` | 可変量算術右シフト |

### 論理右シフト: `s[0] = s[8] >>u s[16]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 8]`<br>`mov r8, rax`<br>`mov rcx, [rsp + 16]`<br>`mov rax, r8`<br>`shr rax, cl`<br>`mov [rsp + 0], rax` | ゼロ拡張 |
| **ARM64** | `ldr x0, [sp, #8]`<br>`ldr x1, [sp, #16]`<br>`lsrv x0, x0, x1`<br>`str x0, [sp, #0]` | 可変量論理右シフト |

---

## 複合代入演算

### 加算代入: `s[0] += s[8]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 0]`<br>`mov rbx, [rsp + 8]`<br>`add rax, rbx`<br>`mov [rsp + 0], rax` | デスティネーションをロード→演算→ストア |
| **ARM64** | `ldr x0, [sp, #0]`<br>`ldr x1, [sp, #8]`<br>`add x0, x0, x1`<br>`str x0, [sp, #0]` | 同上 |

その他の複合代入（`-=`, `*=`, `/s=`, `&=` など）も同様のパターン。

---

## 制御フロー

### 無条件ジャンプ: `goto label`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `jmp _label` | 相対ジャンプ |
| **ARM64** | `b _label` | 相対ブランチ |

### 条件付きジャンプ: `goto label if s[0] >s s[8]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 0]`<br>`mov rbx, [rsp + 8]`<br>`cmp rax, rbx`<br>`jg _label` | 符号付き比較 |
| **ARM64** | `ldr x0, [sp, #0]`<br>`ldr x1, [sp, #8]`<br>`cmp x0, x1`<br>`b.gt _label` | 符号付き比較 |

### 比較演算子対応表

| KAIR演算子 | x64命令 | ARM64命令 | 意味 |
|------------|---------|-----------|------|
| `==` | `je` | `b.eq` | 等しい |
| `!=` | `jne` | `b.ne` | 等しくない |
| `<s` | `jl` | `b.lt` | 符号付き小なり |
| `<u` | `jb` | `b.lo` | 符号なし小なり |
| `<=s` | `jle` | `b.le` | 符号付き以下 |
| `<=u` | `jbe` | `b.ls` | 符号なし以下 |
| `>s` | `jg` | `b.gt` | 符号付き大なり |
| `>u` | `ja` | `b.hi` | 符号なし大なり |
| `>=s` | `jge` | `b.ge` | 符号付き以上 |
| `>=u` | `jae` | `b.hs` | 符号なし以上 |

---

## システムコール

### Windows x64: `syscall ExitProcess, 42`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64 (Windows)** | `mov rcx, 42`<br>`mov rax, rsp`<br>`and rax, 15`<br>`sub rsp, rax`<br>`sub rsp, 32`<br>`call ExitProcess` | 引数1: RCX<br>16バイトアライメント<br>シャドウスペース32バイト |
| **ARM64 (Windows)** | 未実装 | - |

### Linux x64: 未実装

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64 (Linux)** | `mov rax, syscall_number`<br>`mov rdi, arg1`<br>`syscall` | System V AMD64 ABI |
| **ARM64 (Linux)** | `mov x8, syscall_number`<br>`mov x0, arg1`<br>`svc #0` | AAPCS64 |

---

## スタックポインタ操作

**重要**: KAIR ではアセンブリと同じ記法を使用します。スタックは下方向（低位アドレス）に成長するため、確保には `-=` を使用します。

### スタック確保: `sp -= 40`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, rsp`<br>`mov rbx, 40`<br>`sub rax, rbx`<br>`mov rsp, rax` | アセンブリと同じ記法<br>完全ナイーブ実装 |
| **ARM64** | `sub sp, sp, #40` | 即値で直接操作可能 |

### スタック解放: `sp += 16`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, rsp`<br>`mov rbx, 16`<br>`add rax, rbx`<br>`mov rsp, rax` | アセンブリと同じ記法<br>完全ナイーブ実装 |
| **ARM64** | `add sp, sp, #16` | 即値で直接操作可能 |

---

## ベースアドレス値

### データセクションアドレス取得: `s[8] = data`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `lea rax, [rip + _data_base]`<br>`mov [rsp + 8], rax` | RIP相対アドレッシング |
| **ARM64** | `adrp x0, _data_base`<br>`add x0, x0, :lo12:_data_base`<br>`str x0, [sp, #8]` | ページアドレス + オフセット |

### 定数セクションアドレス取得: `s[8] = const`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `lea rax, [rip + _rodata_base]`<br>`mov [rsp + 8], rax` | RIP相対アドレッシング |
| **ARM64** | `adrp x0, _rodata_base`<br>`add x0, x0, :lo12:_rodata_base`<br>`str x0, [sp, #8]` | ページアドレス + オフセット |

**重要:** `d[0]` は値、`data` はアドレス

---

## スタックアライメント

### 16バイト境界整列: `align 16`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, rsp`<br>`and rax, 15`<br>`sub rsp, rax` | RSP % 16 を計算して調整 |
| **ARM64** | `add x0, sp, #0`<br>`and x0, x0, #15`<br>`sub sp, sp, x0` | SP % 16 を計算して調整 |

### 8バイト境界整列: `align 8`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, rsp`<br>`and rax, 7`<br>`sub rsp, rax` | RSP % 8 を計算して調整 |
| **ARM64** | `add x0, sp, #0`<br>`and x0, x0, #7`<br>`sub sp, sp, x0` | SP % 8 を計算して調整 |

---

## 条件付き代入と三項演算子

### 条件付き代入: `s[0] = 10 if s[8] >s 0`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64 (最適化版)** | `mov rax, 10`<br>`mov rbx, [rsp + 0]`<br>`mov r12, [rsp + 8]`<br>`mov r13, 0`<br>`cmp r12, r13`<br>`cmovle rax, rbx`<br>`mov [rsp + 0], rax` | cmovで分岐を排除<br>置換値をraxに、元の値をrbxに<br>条件が偽なら元の値を保持 |
| **ARM64 (最適化版)** | `mov x0, #10`<br>`ldr x1, [sp, #0]`<br>`ldr x2, [sp, #8]`<br>`mov x3, #0`<br>`cmp x2, x3`<br>`csel x0, x0, x1, gt`<br>`str x0, [sp, #0]` | cselで分岐を排除<br>gt条件でx0、そうでなければx1を選択 |

### 三項演算子: `s[0] = (s[8] >s 0) ? 100 : 200`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64 (最適化版)** | `mov rax, 100`<br>`mov rbx, 200`<br>`mov r12, [rsp + 8]`<br>`mov r13, 0`<br>`cmp r12, r13`<br>`cmovle rax, rbx`<br>`mov [rsp + 0], rax` | cmovで分岐を排除<br>真の値をraxに、偽の値をrbxに<br>条件が偽なら偽の値を選択 |
| **ARM64 (最適化版)** | `mov x0, #100`<br>`mov x1, #200`<br>`ldr x2, [sp, #8]`<br>`mov x3, #0`<br>`cmp x2, x3`<br>`csel x0, x0, x1, gt`<br>`str x0, [sp, #0]` | cselで分岐を排除<br>gt条件でx0、そうでなければx1を選択 |

---

## その他

### nop: `pass`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `nop` | 1バイトNOP |
| **ARM64** | `nop` | 4バイトNOP |

### 複数nop: `pass * 5`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `nop`<br>`nop`<br>`nop`<br>`nop`<br>`nop` | 指定回数分のNOP |
| **ARM64** | `nop`<br>`nop`<br>`nop`<br>`nop`<br>`nop` | 同上 |

---

## 重要な注意事項

### x64実装の制約

1. **push/pop禁止**: コンパイラ内部実装で `push`/`pop` を使用しない
   - 理由: RSPが変化すると `s[offset]` のアクセス先がずれる
   - 代替: r8, r9 などの汎用レジスタを使用

2. **Windows x64呼び出し規約**:
   - **スタックアライメント**: call直前はRSP % 16 == 0が必須
   - **シャドウスペース**: 32バイト必須(rcx/rdx/r8/r9用)
   - **標準的な呼び出し手順**: `align 16` → `sub rsp, 32` → `call` → `add rsp, 32`
   - **レジスタのボラティリティ**:
     - 揮発性(caller-save): RCX, RDX, R8, R9, R10, R11, RAX
     - 非揮発性(callee-save): RBX, RBP, RDI, RSI, RSP, R12-R15
   - **現段階の扱い**: 自前関数をエクスポートしないため、非揮発性レジスタの保存は不要

### ARM64実装の特徴

1. **3オペランド演算**: x64より自然に実装可能
2. **即値制限**: 一部の即値は `movz`/`movk` で複数命令に分割
3. **アライメント**: スタックは16バイト境界必須

### 実装済みの最適化

以下の最適化は既に実装されています:
- **RIP相対直接メモリアクセス** (x64): LEA経由からRIP相対直接アクセスに簡潔化
- **メモリオペランド利用** (x64): add/sub/imul/and/or/xor で右辺メモリオペランドを直接使用
- **非揮発性レジスタ優先**: r8の代わりにrbx/r12-r15を使用（将来の関数呼び出し対応に備える）
- **条件式の分岐削減**: 条件付き代入・三項演算子でcmov/cselを使用し分岐を排除

### 将来の最適化課題

この表は**ナイーブ実装**をベースとしています。以下の最適化は将来の課題:
- 不要なレジスタ間コピーのさらなる削減
- 定数畳み込み
- レジスタ割り当ての改善（現在は固定割り当て）
- デッドコード除去
