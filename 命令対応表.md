# KAIR 命令対応表（完全ナイーブ実装）

この表は、KAIR命令がx64とARM64でどのように実装されるかを示します。
**完全ナイーブ実装**のため、最適化は一切行いません。

## 表記規則

- `rax`, `rbx` など: x64 レジスタ
- `x0`, `x1` など: ARM64 レジスタ
- `[...]`: メモリアクセス
- `// ...`: コメント

---

## メモリアクセス

### 基本アクセス: `s[0] = 10`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, 10`<br>`mov [rsp + 0], rax` | 即値をレジスタ経由でストア |
| **ARM64** | `mov x0, #10`<br>`str x0, [sp, #0]` | 即値をレジスタ経由でストア |

### ロード: `s[0] = s[8]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 8]`<br>`mov [rsp + 0], rax` | メモリ→レジスタ→メモリ |
| **ARM64** | `ldr x0, [sp, #8]`<br>`str x0, [sp, #0]` | メモリ→レジスタ→メモリ |

### データセクションアクセス: `s[0] = d[8]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [_data_base + 8]`<br>`mov [rsp + 0], rax` | RIP相対アドレッシング（default rel） |
| **ARM64** | `adrp x0, _data_base`<br>`ldr x0, [x0, #8]`<br>`str x0, [sp, #0]` | ページアドレス + オフセット |

### 読み取り専用アクセス: `s[0] = c[8]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [_rodata_base + 8]`<br>`mov [rsp + 0], rax` | RIP相対アドレッシング |
| **ARM64** | `adrp x0, _rodata_base`<br>`ldr x0, [x0, #8]`<br>`str x0, [sp, #0]` | ページアドレス + オフセット |

---

## 算術演算

### 加算: `s[0] = s[8] + s[16]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 8]`<br>`mov r8, rax`<br>`mov rbx, [rsp + 16]`<br>`mov rax, r8`<br>`add rax, rbx`<br>`mov [rsp + 0], rax` | push/pop 禁止のため r8 使用 |
| **ARM64** | `ldr x0, [sp, #8]`<br>`ldr x1, [sp, #16]`<br>`add x0, x0, x1`<br>`str x0, [sp, #0]` | 3オペランド演算が自然 |

### 減算: `s[0] = s[8] - s[16]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 8]`<br>`mov r8, rax`<br>`mov rbx, [rsp + 16]`<br>`mov rax, r8`<br>`sub rax, rbx`<br>`mov [rsp + 0], rax` | push/pop 禁止 |
| **ARM64** | `ldr x0, [sp, #8]`<br>`ldr x1, [sp, #16]`<br>`sub x0, x0, x1`<br>`str x0, [sp, #0]` | 3オペランド演算 |

### 乗算: `s[0] = s[8] * s[16]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 8]`<br>`mov r8, rax`<br>`mov rbx, [rsp + 16]`<br>`mov rax, r8`<br>`imul rax, rbx`<br>`mov [rsp + 0], rax` | 符号付き乗算 |
| **ARM64** | `ldr x0, [sp, #8]`<br>`ldr x1, [sp, #16]`<br>`mul x0, x0, x1`<br>`str x0, [sp, #0]` | 符号なし乗算（下位64bit同じ） |

### 符号付き除算: `s[0] = s[8] /s s[16]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 8]`<br>`mov r8, rax`<br>`mov rbx, [rsp + 16]`<br>`mov rax, r8`<br>`cqo`<br>`idiv rbx`<br>`mov [rsp + 0], rax` | RAX:RDX ÷ RBX → RAX |
| **ARM64** | `ldr x0, [sp, #8]`<br>`ldr x1, [sp, #16]`<br>`sdiv x0, x0, x1`<br>`str x0, [sp, #0]` | 符号付き除算命令 |

### 符号なし除算: `s[0] = s[8] /u s[16]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 8]`<br>`mov r8, rax`<br>`mov rbx, [rsp + 16]`<br>`mov rax, r8`<br>`xor rdx, rdx`<br>`div rbx`<br>`mov [rsp + 0], rax` | RDXクリア必須 |
| **ARM64** | `ldr x0, [sp, #8]`<br>`ldr x1, [sp, #16]`<br>`udiv x0, x0, x1`<br>`str x0, [sp, #0]` | 符号なし除算命令 |

### 剰余（符号付き）: `s[0] = s[8] %s s[16]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 8]`<br>`mov r8, rax`<br>`mov rbx, [rsp + 16]`<br>`mov rax, r8`<br>`cqo`<br>`idiv rbx`<br>`mov [rsp + 0], rdx` | 商はRAX、余りはRDX |
| **ARM64** | `ldr x0, [sp, #8]`<br>`ldr x1, [sp, #16]`<br>`sdiv x2, x0, x1`<br>`msub x0, x2, x1, x0`<br>`str x0, [sp, #0]` | x0 - (x0/x1)*x1 で計算 |

---

## ビット演算

### AND: `s[0] = s[8] & s[16]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 8]`<br>`mov r8, rax`<br>`mov rbx, [rsp + 16]`<br>`mov rax, r8`<br>`and rax, rbx`<br>`mov [rsp + 0], rax` | ビット単位AND |
| **ARM64** | `ldr x0, [sp, #8]`<br>`ldr x1, [sp, #16]`<br>`and x0, x0, x1`<br>`str x0, [sp, #0]` | ビット単位AND |

### OR: `s[0] = s[8] | s[16]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 8]`<br>`mov r8, rax`<br>`mov rbx, [rsp + 16]`<br>`mov rax, r8`<br>`or rax, rbx`<br>`mov [rsp + 0], rax` | ビット単位OR |
| **ARM64** | `ldr x0, [sp, #8]`<br>`ldr x1, [sp, #16]`<br>`orr x0, x0, x1`<br>`str x0, [sp, #0]` | ビット単位OR |

### XOR: `s[0] = s[8] ^ s[16]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 8]`<br>`mov r8, rax`<br>`mov rbx, [rsp + 16]`<br>`mov rax, r8`<br>`xor rax, rbx`<br>`mov [rsp + 0], rax` | ビット単位XOR |
| **ARM64** | `ldr x0, [sp, #8]`<br>`ldr x1, [sp, #16]`<br>`eor x0, x0, x1`<br>`str x0, [sp, #0]` | ビット単位XOR |

### NOT: `s[0] = ~s[8]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 8]`<br>`not rax`<br>`mov [rsp + 0], rax` | ビット反転 |
| **ARM64** | `ldr x0, [sp, #8]`<br>`mvn x0, x0`<br>`str x0, [sp, #0]` | ビット反転 |

### 左シフト: `s[0] = s[8] << s[16]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 8]`<br>`mov r8, rax`<br>`mov rcx, [rsp + 16]`<br>`mov rax, r8`<br>`shl rax, cl`<br>`mov [rsp + 0], rax` | シフト量はCL（RCXの下位8bit） |
| **ARM64** | `ldr x0, [sp, #8]`<br>`ldr x1, [sp, #16]`<br>`lsl x0, x0, x1`<br>`str x0, [sp, #0]` | レジスタでシフト量指定可 |

### 算術右シフト: `s[0] = s[8] >>s s[16]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 8]`<br>`mov r8, rax`<br>`mov rcx, [rsp + 16]`<br>`mov rax, r8`<br>`sar rax, cl`<br>`mov [rsp + 0], rax` | 符号ビット拡張 |
| **ARM64** | `ldr x0, [sp, #8]`<br>`ldr x1, [sp, #16]`<br>`asr x0, x0, x1`<br>`str x0, [sp, #0]` | 符号ビット拡張 |

### 論理右シフト: `s[0] = s[8] >>u s[16]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 8]`<br>`mov r8, rax`<br>`mov rcx, [rsp + 16]`<br>`mov rax, r8`<br>`shr rax, cl`<br>`mov [rsp + 0], rax` | ゼロ拡張 |
| **ARM64** | `ldr x0, [sp, #8]`<br>`ldr x1, [sp, #16]`<br>`lsr x0, x0, x1`<br>`str x0, [sp, #0]` | ゼロ拡張 |

---

## 複合代入演算

### 加算代入: `s[0] += s[8]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 0]`<br>`mov rbx, [rsp + 8]`<br>`add rax, rbx`<br>`mov [rsp + 0], rax` | デスティネーションをロード→演算→ストア |
| **ARM64** | `ldr x0, [sp, #0]`<br>`ldr x1, [sp, #8]`<br>`add x0, x0, x1`<br>`str x0, [sp, #0]` | 同上 |

その他の複合代入（`-=`, `*=`, `/s=`, `&=` など）も同様のパターン。

---

## 制御フロー

### 無条件ジャンプ: `goto label`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `jmp _label` | 相対ジャンプ |
| **ARM64** | `b _label` | 相対ブランチ |

### 条件付きジャンプ: `goto label if s[0] >s s[8]`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 0]`<br>`mov rbx, [rsp + 8]`<br>`cmp rax, rbx`<br>`jg _label` | 符号付き比較 |
| **ARM64** | `ldr x0, [sp, #0]`<br>`ldr x1, [sp, #8]`<br>`cmp x0, x1`<br>`b.gt _label` | 符号付き比較 |

### 比較演算子対応表

| KAIR演算子 | x64命令 | ARM64命令 | 意味 |
|------------|---------|-----------|------|
| `==` | `je` | `b.eq` | 等しい |
| `!=` | `jne` | `b.ne` | 等しくない |
| `<s` | `jl` | `b.lt` | 符号付き小なり |
| `<u` | `jb` | `b.lo` | 符号なし小なり |
| `<=s` | `jle` | `b.le` | 符号付き以下 |
| `<=u` | `jbe` | `b.ls` | 符号なし以下 |
| `>s` | `jg` | `b.gt` | 符号付き大なり |
| `>u` | `ja` | `b.hi` | 符号なし大なり |
| `>=s` | `jge` | `b.ge` | 符号付き以上 |
| `>=u` | `jae` | `b.hs` | 符号なし以上 |

---

## システムコール

### Windows x64: `syscall ExitProcess, 42`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64 (Windows)** | `mov rcx, 42`<br>`mov rax, rsp`<br>`and rax, 15`<br>`sub rsp, rax`<br>`sub rsp, 32`<br>`call ExitProcess` | 引数1: RCX<br>16バイトアライメント<br>シャドウスペース32バイト |
| **ARM64 (Windows)** | 未実装 | - |

### Linux x64: 未実装

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64 (Linux)** | `mov rax, syscall_number`<br>`mov rdi, arg1`<br>`syscall` | System V AMD64 ABI |
| **ARM64 (Linux)** | `mov x8, syscall_number`<br>`mov x0, arg1`<br>`svc #0` | AAPCS64 |

---

## スタックポインタ操作

**重要**: KIR ではアセンブリと同じ記法を使用します。スタックは下方向（低位アドレス）に成長するため、確保には `-=` を使用します。

### スタック確保: `sp -= 40`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, rsp`<br>`mov rbx, 40`<br>`sub rax, rbx`<br>`mov rsp, rax` | アセンブリと同じ記法<br>完全ナイーブ実装 |
| **ARM64** | `sub sp, sp, #40` | 即値で直接操作可能 |

### スタック解放: `sp += 16`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, rsp`<br>`mov rbx, 16`<br>`add rax, rbx`<br>`mov rsp, rax` | アセンブリと同じ記法<br>完全ナイーブ実装 |
| **ARM64** | `add sp, sp, #16` | 即値で直接操作可能 |

---

## ベースアドレス値

### データセクションアドレス取得: `s[8] = data`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `lea rax, [rel _data_base]`<br>`mov [rsp + 8], rax` | RIP相対アドレッシング |
| **ARM64** | `adrp x0, _data_base`<br>`add x0, x0, :lo12:_data_base`<br>`str x0, [sp, #8]` | ページアドレス + オフセット |

### 定数セクションアドレス取得: `s[8] = const`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `lea rax, [rel _rodata_base]`<br>`mov [rsp + 8], rax` | RIP相対アドレッシング |
| **ARM64** | `adrp x0, _rodata_base`<br>`add x0, x0, :lo12:_rodata_base`<br>`str x0, [sp, #8]` | ページアドレス + オフセット |

**重要:** `d[0]` は値、`data` はアドレス

---

## スタックアライメント

### 16バイト境界整列: `align 16`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, rsp`<br>`and rax, 15`<br>`sub rsp, rax` | RSP % 16 を計算して調整 |
| **ARM64** | `mov x0, sp`<br>`and x0, x0, #15`<br>`sub sp, sp, x0` | SP % 16 を計算して調整 |

### 8バイト境界整列: `align 8`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, rsp`<br>`and rax, 7`<br>`sub rsp, rax` | RSP % 8 を計算して調整 |
| **ARM64** | `mov x0, sp`<br>`and x0, x0, #7`<br>`sub sp, sp, x0` | SP % 8 を計算して調整 |

---

## 条件付き代入と三項演算子

### 条件付き代入: `s[0] = 10 if s[8] >s 0`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 8]`<br>`mov rbx, 0`<br>`cmp rax, rbx`<br>`jle _skip_assign_0`<br>`mov rax, 10`<br>`mov [rsp + 0], rax`<br>`_skip_assign_0:` | 条件不成立時はスキップ |
| **ARM64** | `ldr x0, [sp, #8]`<br>`mov x1, #0`<br>`cmp x0, x1`<br>`b.le _skip_assign_0`<br>`mov x0, #10`<br>`str x0, [sp, #0]`<br>`_skip_assign_0:` | 同上 |

### 三項演算子: `s[0] = (s[8] >s 0) ? 100 : 200`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `mov rax, [rsp + 8]`<br>`mov rbx, 0`<br>`cmp rax, rbx`<br>`jle _ternary_false_0`<br>`mov rax, 100`<br>`jmp _ternary_end_0`<br>`_ternary_false_0:`<br>`mov rax, 200`<br>`_ternary_end_0:`<br>`mov [rsp + 0], rax` | 条件分岐で値を選択 |
| **ARM64** | `ldr x0, [sp, #8]`<br>`mov x1, #0`<br>`cmp x0, x1`<br>`b.le _ternary_false_0`<br>`mov x0, #100`<br>`b _ternary_end_0`<br>`_ternary_false_0:`<br>`mov x0, #200`<br>`_ternary_end_0:`<br>`str x0, [sp, #0]` | 同上 |

---

## その他

### nop: `pass`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `nop` | 1バイトNOP |
| **ARM64** | `nop` | 4バイトNOP |

### 複数nop: `pass * 5`

| アーキテクチャ | 実装 | 備考 |
|--------------|------|------|
| **x64** | `nop`<br>`nop`<br>`nop`<br>`nop`<br>`nop` | 指定回数分のNOP |
| **ARM64** | `nop`<br>`nop`<br>`nop`<br>`nop`<br>`nop` | 同上 |

---

## 重要な注意事項

### x64実装の制約

1. **push/pop禁止**: コンパイラ内部実装で `push`/`pop` を使用しない
   - 理由: RSPが変化すると `s[offset]` のアクセス先がずれる
   - 代替: r8, r9 などの汎用レジスタを使用

2. **スタックアライメント**: システムコール前に16バイト境界に調整
   - Windows x64呼び出し規約の要求

3. **シャドウスペース**: Windows x64では32バイト必須

### ARM64実装の特徴

1. **3オペランド演算**: x64より自然に実装可能
2. **即値制限**: 一部の即値は `movz`/`movk` で複数命令に分割
3. **アライメント**: スタックは16バイト境界必須

### 最適化の余地

この表は**完全ナイーブ実装**です。以下の最適化は将来の課題:
- 不要なレジスタ間コピーの削減
- メモリアクセスの統合
- 定数畳み込み
- レジスタ割り当ての改善
